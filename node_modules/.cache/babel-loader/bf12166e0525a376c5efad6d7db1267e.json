{"ast":null,"code":"/*!\n* tabbable 5.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nvar isContentEditable = function isContentEditable(node) {\n  return node.contentEditable === 'true';\n};\n\nvar getTabindex = function getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n\n\n  if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || node.ownerDocument;\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isHidden = function isHidden(node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n        width = _node$getBoundingClie.width,\n        height = _node$getBoundingClie.height;\n\n    return width === 0 && height === 0;\n  }\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) ||\n  /* For a details element with a summary, the summary element gets the focused  */\n  isDetailsWithSummary(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  candidates.forEach(function (candidate, i) {\n    var candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  });\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };","map":{"version":3,"sources":["../src/index.js"],"names":["candidateSelectors","candidateSelector","matches","Element","getCandidates","candidates","Array","el","includeContainer","isContentEditable","node","getTabindex","tabindexAttr","parseInt","isNaN","sortOrderedTabbables","a","b","isInput","isHiddenInput","isDetailsWithSummary","r","child","getCheckedRadio","i","nodes","isTabbableRadio","radioScope","queryRadios","window","radioSet","console","err","checked","isRadio","isNonTabbableRadio","isHidden","getComputedStyle","isDirectSummary","nodeUnderDetails","displayCheck","width","height","isNodeMatchingSelectorFocusable","options","isNodeMatchingSelectorTabbable","tabbable","regularTabbables","orderedTabbables","candidateTabindex","documentOrder","tabIndex","candidate","tabbableNodes","focusable","isTabbable","focusableCandidateSelector","isFocusable"],"mappings":"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","sourcesContent":["const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nconst isContentEditable = function (node) {\n  return node.contentEditable === 'true';\n};\n\nconst getTabindex = function (node) {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n  if (\n    (node.nodeName === 'AUDIO' ||\n      node.nodeName === 'VIDEO' ||\n      node.nodeName === 'DETAILS') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isHidden = function (node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    const { width, height } = node.getBoundingClientRect();\n    return width === 0 && height === 0;\n  }\n\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options.displayCheck) ||\n    /* For a details element with a summary, the summary element gets the focused  */\n    isDetailsWithSummary(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    !isNodeMatchingSelectorFocusable(options, node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  const regularTabbables = [];\n  const orderedTabbables = [];\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorTabbable.bind(null, options)\n  );\n\n  candidates.forEach(function (candidate, i) {\n    const candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  });\n\n  const tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorFocusable.bind(null, options)\n  );\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n"]},"metadata":{},"sourceType":"module"}